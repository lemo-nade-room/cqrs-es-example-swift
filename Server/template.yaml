AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: CQRS ES Example Swift

Globals:
  Function:
    Architectures:
      - arm64
    Timeout: 10
    MemorySize: 128
    Tracing: Active
    LoggingConfig:
      ApplicationLogLevel: DEBUG
      LogFormat: JSON
Parameters:
  CommandServerFunctionImageUri:
    Type: String
    Description: ECR URI for Command
  QueryServerFunctionImageUri:
    Type: String
    Description: ECR URI for Query
  ServerEnvironment:
    Type: String
    Description: Serverの環境（Staging)
Resources:
  ServerHttpApi:
    Type: AWS::Serverless::HttpApi
    Properties:
      Name: CQRS ES Example Swift Server
      StageName: Stage
  CommandServerFunction:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Image
      ImageUri: !Ref CommandServerFunctionImageUri
      # Layerはコンテナイメージでは使用できないため、
      # X-Rayへの送信はアプリケーション内のOpenTelemetryから直接行います
      Environment:
        Variables:
          SERVER: !Ref ServerEnvironment
          AWS_XRAY_CONTEXT_MISSING: LOG_ERROR
          # CloudWatch Application SignalsのOTLPエンドポイントを使用
          OTEL_EXPORTER_OTLP_ENDPOINT: !Sub https://xray.${AWS::Region}.amazonaws.com
          # X-RayのトレースIDフォーマットを使用
          OTEL_PROPAGATORS: xray
          # VaporのLogLevelをDEBUGに設定
          LOG_LEVEL: DEBUG
          # Application Signals用の設定
          OTEL_METRICS_EXPORTER: none
          OTEL_AWS_APPLICATION_SIGNALS_ENABLED: true
          OTEL_RESOURCE_ATTRIBUTES: service.name=CommandServer
      Policies:
        - AWSXRayDaemonWriteAccess
        # Application Signalsでメトリクスを送信するための追加権限
        - Statement:
          - Effect: Allow
            Action:
              - cloudwatch:PutMetricData
            Resource: '*'
      Events:
        CommandHttpApi:
          Type: HttpApi
          Properties:
            ApiId: !Ref ServerHttpApi
            Method: ANY
            Path: /command/{proxy+}
  QueryServerFunction:
    Type: AWS::Serverless::Function
    Properties:
      PackageType: Image
      ImageUri: !Ref QueryServerFunctionImageUri
      # Layerはコンテナイメージでは使用できないため、
      # X-Rayへの送信はアプリケーション内のOpenTelemetryから直接行います
      Environment:
        Variables:
          SERVER: !Ref ServerEnvironment
          AWS_XRAY_CONTEXT_MISSING: LOG_ERROR
          # CloudWatch Application SignalsのOTLPエンドポイントを使用
          OTEL_EXPORTER_OTLP_ENDPOINT: !Sub https://xray.${AWS::Region}.amazonaws.com
          # X-RayのトレースIDフォーマットを使用
          OTEL_PROPAGATORS: xray
          # VaporのLogLevelをDEBUGに設定
          LOG_LEVEL: DEBUG
          # Application Signals用の設定
          OTEL_METRICS_EXPORTER: none
          OTEL_AWS_APPLICATION_SIGNALS_ENABLED: true
          OTEL_RESOURCE_ATTRIBUTES: service.name=QueryServer
      Policies:
        - AWSXRayDaemonWriteAccess
        # Application Signalsでメトリクスを送信するための追加権限
        - Statement:
          - Effect: Allow
            Action:
              - cloudwatch:PutMetricData
            Resource: '*'
      Events:
        QueryHttpApi:
          Type: HttpApi
          Properties:
            ApiId: !Ref ServerHttpApi
            Method: ANY
            Path: /query/{proxy+}

  # X-Ray Trace Segment Destination設定用のカスタムリソース
  # 注：これはリージョンレベルの設定で、一度設定すれば全てのLambda関数に適用されます
  # 本来はTerraformで管理すべきですが、Application SignalsとX-Ray OTLPを使用するための
  # 必須設定なので、SAMテンプレートに含めています
  UpdateTraceDestinationFunction:
    Type: AWS::Serverless::Function
    Properties:
      InlineCode: |
        import json
        import boto3
        import urllib3
        
        SUCCESS = "SUCCESS"
        FAILED = "FAILED"
        
        http = urllib3.PoolManager()
        
        def send(event, context, responseStatus, responseData, physicalResourceId=None, noEcho=False, reason=None):
            responseUrl = event['ResponseURL']
            
            responseBody = {
                'Status': responseStatus,
                'Reason': reason or "See the details in CloudWatch Log Stream: " + context.log_stream_name,
                'PhysicalResourceId': physicalResourceId or context.log_stream_name,
                'StackId': event['StackId'],
                'RequestId': event['RequestId'],
                'LogicalResourceId': event['LogicalResourceId'],
                'NoEcho': noEcho,
                'Data': responseData
            }
            
            json_responseBody = json.dumps(responseBody)
            
            headers = {
                'content-type': '',
                'content-length': str(len(json_responseBody))
            }
            
            try:
                response = http.request('PUT', responseUrl,
                                        headers=headers,
                                        body=json_responseBody)
                print("Status code: ", response.status)
            except Exception as e:
                print("send(..) failed executing http.request(..):", e)
        
        def handler(event, context):
            print(f"Received event: {json.dumps(event)}")
            
            try:
                request_type = event['RequestType']
                
                if request_type in ['Create', 'Update']:
                    # X-Rayクライアントを作成（リージョンを明示的に指定）
                    import os
                    region = os.environ.get('AWS_REGION', 'ap-northeast-1')
                    xray = boto3.client('xray', region_name=region)
                    print(f"Using region: {region}")
                    
                    # 現在の設定を確認
                    try:
                        current = xray.get_trace_segment_destination()
                        print(f"Current trace destination: {current}")
                    except Exception as e:
                        print(f"Failed to get current destination: {e}")
                    
                    # CloudWatch LogsをトレースのデスティネーションとしてUpdateする
                    response = xray.update_trace_segment_destination(
                        Destination='CloudWatchLogs'
                    )
                    print(f"UpdateTraceSegmentDestination response: {response}")
                    
                    # レスポンスのステータスを確認
                    if response.get('Status') in ['PENDING', 'ACTIVE']:
                        send(event, context, SUCCESS, {
                            'Message': 'Trace destination updated',
                            'Destination': response.get('Destination'),
                            'Status': response.get('Status')
                        })
                    else:
                        send(event, context, FAILED, {
                            'Error': f"Unexpected status: {response.get('Status')}"
                        })
                else:
                    # Delete時は何もしない
                    print(f"Handling {request_type} request - no action needed")
                    send(event, context, SUCCESS, {'Message': 'Delete completed'})
            except Exception as e:
                import traceback
                error_details = traceback.format_exc()
                print(f"Error occurred: {str(e)}")
                print(f"Stack trace: {error_details}")
                send(event, context, FAILED, {'Error': str(e)})
      Runtime: python3.12
      Handler: index.handler
      Timeout: 60
      Policies:
        - Statement:
            - Effect: Allow
              Action:
                - xray:UpdateTraceSegmentDestination
              Resource: '*'

  # カスタムリソースを実行
  UpdateTraceDestination:
    Type: Custom::UpdateTraceDestination
    Properties:
      ServiceToken: !GetAtt UpdateTraceDestinationFunction.Arn