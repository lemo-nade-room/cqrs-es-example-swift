version: 0.2

env:
  shell: bash
  exported-variables:
    - IMAGE_URI
    - BUILD_SKIPPED

phases:
  install:
    commands:
      # Enable BuildKit
      - export DOCKER_BUILDKIT=1
      - export COMPOSE_DOCKER_CLI_BUILD=1
      
  pre_build:
    commands:
      - echo "ðŸ” Checking for changes in $SERVICE_NAME..."
      - |
        # S3ãƒ™ãƒ¼ã‚¹ã®å¤‰æ›´æ¤œçŸ¥
        S3_BUCKET="change-detection-bucket-983760593510"
        COMMIT_FILE="last-commit-${SERVICE_NAME,,}.txt"
        
        # å‰å›žã®ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ã‚’å–å¾—
        aws s3 cp "s3://${S3_BUCKET}/${COMMIT_FILE}" ./last-commit.txt 2>/dev/null || echo "none" > ./last-commit.txt
        LAST_COMMIT=$(cat ./last-commit.txt)
        CURRENT_COMMIT=$CODEBUILD_RESOLVED_SOURCE_VERSION
        
        echo "Last commit: $LAST_COMMIT"
        echo "Current commit: $CURRENT_COMMIT"
        
        # åˆå›žãƒ“ãƒ«ãƒ‰ã¾ãŸã¯ã‚³ãƒŸãƒƒãƒˆãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆ
        if [ "$LAST_COMMIT" = "none" ] || [ "$LAST_COMMIT" != "$CURRENT_COMMIT" ]; then
          echo "ðŸ”„ Commit changed, checking for service-specific changes..."
          
          # DynamoDBã‹ã‚‰å‰å›žãƒ“ãƒ«ãƒ‰ã—ãŸãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã‚’å–å¾—
          LAST_HASH=$(aws dynamodb get-item \
            --table-name service-change-tracking \
            --key "{\"service_name\": {\"S\": \"$SERVICE_NAME\"}}" \
            --query 'Item.file_hash.S' --output text 2>/dev/null || echo "none")
          
          # ç¾åœ¨ã®ã‚µãƒ¼ãƒ“ã‚¹é–¢é€£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒãƒƒã‚·ãƒ¥ã‚’è¨ˆç®—
          if [ "$SERVICE_NAME" = "Command" ]; then
            CURRENT_HASH=$(find Server/Sources/Command Server/Sources/App Server/Sources/Core Server/Sources/EventStore Server/Package.* -type f \
              -not -path "*/.*" -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          elif [ "$SERVICE_NAME" = "Query" ]; then
            CURRENT_HASH=$(find Server/Sources/Query Server/Sources/App Server/Sources/Core Server/Sources/QueryStore Server/Package.* -type f \
              -not -path "*/.*" -exec sha256sum {} \; | sort | sha256sum | cut -d' ' -f1)
          fi
          
          echo "Last file hash: $LAST_HASH"
          echo "Current file hash: $CURRENT_HASH"
          
          if [ "$LAST_HASH" = "$CURRENT_HASH" ] && [ "$LAST_HASH" != "none" ]; then
            export BUILD_SKIPPED=true
            echo "âœ… No changes detected for $SERVICE_NAME service"
          else
            export BUILD_SKIPPED=false
            echo "ðŸš€ Changes detected for $SERVICE_NAME service"
            
            # DynamoDBã«æ–°ã—ã„ãƒãƒƒã‚·ãƒ¥ã‚’ä¿å­˜
            aws dynamodb put-item \
              --table-name service-change-tracking \
              --item "{
                \"service_name\": {\"S\": \"$SERVICE_NAME\"},
                \"file_hash\": {\"S\": \"$CURRENT_HASH\"},
                \"last_commit\": {\"S\": \"$CURRENT_COMMIT\"},
                \"timestamp\": {\"S\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"}
              }"
          fi
        else
          export BUILD_SKIPPED=true
          echo "âœ… Same commit, skipping build"
        fi
      
      - |
        if [ "$BUILD_SKIPPED" = "false" ]; then
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$REPOSITORY_URL"
          export CACHE_REF="$REPOSITORY_URL:cache"
        fi

  build:
    commands:
      - |
        if [ "$BUILD_SKIPPED" = "true" ]; then
          echo "ðŸ“¦ Build skipped. Using existing image."
          # Get the latest image digest
          DIGEST=$(aws ecr describe-images \
            --repository-name $(echo $REPOSITORY_URL | cut -d'/' -f2-) \
            --image-ids imageTag=$TAG \
            --query 'imageDetails[0].imageDigest' --output text)
          export "IMAGE_URI=$REPOSITORY_URL@$DIGEST"
        else
          echo "ðŸ—ï¸ Building Docker image..."
          START_TIME=$(date +%s)
          
          # Pull cache image if exists (ignore errors)
          docker pull $CACHE_REF || true
          
          # Build with standard docker build for Lambda compatibility
          # Use inline cache export for better performance
          docker build \
            --platform linux/arm64 \
            --file "$DOCKERFILE_PATH" \
            --cache-from $CACHE_REF \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --tag "$REPOSITORY_URL:$TAG" \
            --tag "$REPOSITORY_URL:$CODEBUILD_RESOLVED_SOURCE_VERSION" \
            ./Server
          
          END_TIME=$(date +%s)
          BUILD_TIME=$((END_TIME - START_TIME))
          echo "â±ï¸ Docker build completed in ${BUILD_TIME} seconds"
          
          # Push the image
          echo "ðŸ“¤ Pushing images to ECR..."
          docker push "$REPOSITORY_URL:$TAG"
          docker push "$REPOSITORY_URL:$CODEBUILD_RESOLVED_SOURCE_VERSION"
          
          # Also push as cache tag for next builds
          docker tag "$REPOSITORY_URL:$TAG" $CACHE_REF
          docker push $CACHE_REF
          
          # æˆåŠŸã—ãŸã‚‰S3ã«ã‚³ãƒŸãƒƒãƒˆãƒãƒƒã‚·ãƒ¥ã‚’ä¿å­˜
          echo "$CURRENT_COMMIT" > ./current-commit.txt
          aws s3 cp ./current-commit.txt "s3://${S3_BUCKET}/${COMMIT_FILE}"
        fi

  post_build:
    commands:
      - |
        if [ "$BUILD_SKIPPED" = "false" ]; then
          DIGEST=$(aws ecr describe-images \
            --repository-name $(echo $REPOSITORY_URL | cut -d'/' -f2-) \
            --image-ids imageTag=$TAG \
            --query 'imageDetails[0].imageDigest' --output text)
          export "IMAGE_URI=$REPOSITORY_URL@$DIGEST"
        fi
      - echo "IMAGE_URI=$IMAGE_URI"
      - echo "BUILD_SKIPPED=$BUILD_SKIPPED"
      - |
        if [ "$BUILD_SKIPPED" = "true" ]; then
          echo "âœ¨ Build was skipped for $SERVICE_NAME (no relevant changes)"
        else
          echo "ðŸŽ‰ Build completed for $SERVICE_NAME"
        fi

# Note: Docker layer caching is enabled at project level in main.tf